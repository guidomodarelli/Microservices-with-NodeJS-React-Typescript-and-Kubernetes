# **Librer√≠a de Ayuda (Helper Library)** o librer√≠a compartida

He decidido centralizar ciertos elementos en esta librer√≠a porque, al preparar el curso, not√© que muchas funcionalidades se repet√≠an en los distintos servicios.

---

## üöÄ ¬øPor qu√© crear una Helper Library?

La raz√≥n principal es **evitar la duplicaci√≥n de c√≥digo** entre microservicios. Como estamos usando el mismo stack tecnol√≥gico (Node.js, JavaScript y TypeScript), tiene todo el sentido del mundo centralizar componentes, funciones e interfaces reutilizables.

### Flujo de Trabajo

1. **Desarrollo:** Agregamos todas las utilidades necesarias a la librer√≠a.
2. **Publicaci√≥n:** Utilizaremos **GitHub** y **GitHub Actions** para configurar un pipeline.
3. **Distribuci√≥n:** Publicaremos la librer√≠a en **NPM** para poder instalarla f√°cilmente en cualquier servicio o incluso en el frontend con React.

---

## ‚ö†Ô∏è Desaf√≠os de este Enfoque

Adoptar una librer√≠a compartida tiene sus retos. Como desarrolladores, debemos evaluar si estamos dispuestos a lidiar con lo siguiente:

* **Proceso de Actualizaci√≥n:** Si quieres agregar una propiedad a una interfaz o crear una nueva funci√≥n, debes actualizar la librer√≠a, subir el c√≥digo y esperar a que el pipeline de GitHub Actions termine de publicarla.
* **Gesti√≥n de Versiones:** Cada cambio requiere aumentar el n√∫mero de versi√≥n en el `package.json` (ej. de `0.0.1` a `0.0.2`).
* **Actualizaci√≥n de Servicios:** Una vez publicada la nueva versi√≥n, debes ir a cada microservicio que la necesite, actualizar su `package.json` y ejecutar `npm install`.
* *El mejor de los casos:* Solo un servicio necesita la actualizaci√≥n.
* *El peor de los casos:* Tienes que actualizar y reinstalar en todos los servicios, lo cual puede ser tedioso.

---

## üõ†Ô∏è ¬øQu√© incluiremos en nuestra librer√≠a?

Aqu√≠ tienes el desglose de lo que vamos a mover a este paquete centralizado:

### 1. Interfaces

* **Backend:** Moveremos **todas** las interfaces de los microservicios aqu√≠. Solo tendremos que importarlas donde se necesiten.
* **Frontend (React):** Solo incluiremos las interfaces que se compartan entre el frontend y los microservicios. Las interfaces exclusivas de componentes de React se quedar√°n en la app de React para evitar instalar dependencias innecesarias (como el `dispatch`) en el backend.

### 2. M√©todos de Cloudinary

Centralizaremos los m√©todos para la **subida de im√°genes** a Cloudinary.

### 3. Manejadores de Errores (Error Handlers)

Estandarizaremos c√≥mo gestionamos los errores en toda la aplicaci√≥n.

### 4. Middleware de API Gateway

Crearemos un middleware para verificar que las peticiones que llegan a los microservicios provengan leg√≠timamente del **API Gateway** mediante la validaci√≥n de un token espec√≠fico.

### 5. M√©todos de Logger

Configuraremos un m√©todo de registro para enviar logs (errores, advertencias, etc.) a **Elasticsearch** y visualizarlos en **Kibana**.

### 6. Funciones de Utilidad (Helper Functions)

Peque√±as funciones comunes, como m√©todos para convertir texto a may√∫sculas o min√∫sculas y otras transformaciones r√°pidas.
